<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Pontos de √°gua ICNF</title>
  <!-- Prevent page zoom that scales UI controls; keep controls readable on iOS (>=16px) -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />

  <style>
    html, body, #viewDiv {
      margin: 0; padding: 0; height: 100%; width: 100%;
      -webkit-text-size-adjust: 100%; /* avoid iOS auto-zoom adjustments */
    }

    /* ArcGIS widgets: make slightly smaller across devices */
    .esri-ui .esri-widget, .esri-ui button, .esri-ui input, .esri-ui select {
      font-size: 12px; /* >=16px triggers iOS zoom on focus; we don't focus ArcGIS inputs much */
      line-height: 1.2;
    }

    /* Panels */
    #infoPanel, #filterPanel {
      position: absolute;
      background: #fff;
      padding: 6px 8px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,.15);
      font-size: 8px;
      z-index: 10;
      max-height: 50%;
      overflow-y: auto;
      transition: max-height .25s ease, opacity .25s ease, transform .25s ease;
      will-change: max-height, opacity, transform;
      backdrop-filter: saturate(120%) blur(2px);
    }
    #infoPanel { top: 110px; right: 10px; width: min(260px, 42vw); }
    #filterPanel { top: 130px; left: 10px; width: min(160px, 28vw); overflow: hidden; }

    /* Toggle chips */
    .toggle-chip {
      position: absolute;
      top: 4px; left: 4px;
      background: #f2f2f2;
      border: 1px solid #ddd;
      cursor: pointer;
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 14px; /* keep >=14-16 for iOS */
      line-height: 1.1;
      user-select: none;
    }

    /* Loading message */
    #loadingMessage {
      position: absolute; inset: 0;
      display: grid; place-items: center;
      pointer-events: none;
      z-index: 1000;
    }
    #loadingBox {
      background: #fff;
      padding: 12px 14px;
      border-radius: 10px;
      box-shadow: 0 4px 16px rgba(0,0,0,.2);
      font-size: 14px;
    }

    /* Error message */
    #errorMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: #d32f2f;
      color: white;
      padding: 12px 16px;
      border-radius: 6px;
      z-index: 1001;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      display: none;
      max-width: 80%;
      text-align: center;
      font-size: 14px;
    }

    /* Form controls ‚Äì prevent Chrome/iOS zoom on focus by keeping 16px+ */
    select, button {
      width: 100%;
      padding: 8px 10px;
      margin: 4px 0;
      box-sizing: border-box;
      font-size: 12px;
      border-radius: 8px;
    }
    button {
      background-color: #0079c1; color: #fff; border: none; cursor: pointer;
    }
    button:hover { background-color: #005a8c; }
    .btn-ghost {
      background: #fff; color: #000; border: 1px solid #ccc;
    }

    .hidden { display: none !important; }

    /* Info table ‚Äì compact */
    .info-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .info-table th, .info-table td {
      text-align: left;
      padding: 2px 4px;
      border-bottom: 1px dotted #eee;
      vertical-align: top;
      word-break: break-word;
    }
    .info-table th {
      width: 40%;
      color: #444;
      font-weight: 600;
    }

    /* Keep custom buttons tidy in the UI stack */
    .custom-ui {
      display: flex; gap: 6px;
      align-items: center;
      background: transparent;
      border: 0;
      padding: 0;
    }
    .custom-ui button {
      width: auto;
      min-width: 36px;
      padding: 8px;
    }

    /* Ensure UI controls never scale with the map (ArcGIS keeps UI separate already, this avoids accidental page zoom state) */
    .esri-view { touch-action: pan-x pan-y; }

    /* Loading indicator for filtering */
    .filter-loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #0079c1;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>
  <div id="infoPanel" aria-live="polite">
    <button id="toggleInfo" class="toggle-chip" title="Minimizar / Expandir">üìã</button>
    <div id="infoContent"></div>
  </div>

  <div id="filterPanel">
    <button id="toggleFilter" class="toggle-chip" title="Minimizar / Expandir">‚öôÔ∏è</button>
    <strong style="display:block; margin-left: 22px; margin-bottom: 4px; font-size:8px;">Filtrar</strong>
    <select id="distritoFilter" aria-label="Filtrar por distrito">
      <option value="">Todos os distritos</option>
    </select>
    <select id="concelhoFilter" aria-label="Filtrar por concelho">
      <option value="">Todos os concelhos</option>
    </select>
    <div class="custom-ui">
      <button id="applyFilter">Aplicar</button>
      <button id="resetFilter" class="btn-ghost">Repor</button>
    </div>
    <div id="filterLoading" class="filter-loading hidden"></div>
  </div>

  <div id="loadingMessage">
    <div id="loadingBox">A carregar dados WFS‚Ä¶</div>
  </div>

  <div id="errorMessage"></div>

  <script src="https://js.arcgis.com/4.33/"></script>
  <script>
    require([
      "esri/config",
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/geometry/Point",
      "esri/geometry/Polyline",
      "esri/geometry/Extent",
      "esri/geometry/geometryEngine",
      "esri/symbols/SimpleMarkerSymbol",
      "esri/symbols/SimpleLineSymbol",
      "esri/widgets/BasemapGallery",
      "esri/widgets/Expand",
      "esri/widgets/Search",
      "esri/request",
      "esri/layers/GeoJSONLayer"
    ], function(esriConfig, Map, MapView, GraphicsLayer, Graphic, Point, Polyline, Extent, geometryEngine, SimpleMarkerSymbol, SimpleLineSymbol, BasemapGallery, Expand, Search, esriRequest, GeoJSONLayer) {

      // Improve CORS compatibility for Chrome (defensive guards for 'push' on undefined)
      try {
        esriConfig.request = esriConfig.request || {};
        esriConfig.request.corsEnabledServers = Array.isArray(esriConfig.request.corsEnabledServers) ? esriConfig.request.corsEnabledServers : [];
        esriConfig.request.trustedServers = Array.isArray(esriConfig.request.trustedServers) ? esriConfig.request.trustedServers : [];
        for (const host of ["si.icnf.pt", "https://si.icnf.pt"]) {
          if (!esriConfig.request.corsEnabledServers.includes(host)) esriConfig.request.corsEnabledServers.push(host);
          if (!esriConfig.request.trustedServers.includes(host)) esriConfig.request.trustedServers.push(host);
        }
        esriConfig.request.timeout = 20000; // 20s
      } catch (e) {
        console.warn("CORS list init failed:", e);
      }

      const map = new Map({ basemap: "streets-navigation-vector" });
      const view = new MapView({
        container: "viewDiv",
        map,
        center: [-8, 39.5],
        zoom: 7,
        popupEnabled: true
      });

      // Layers
      const pointsLayer = new GraphicsLayer();
      const linesLayer = new GraphicsLayer();
      const filteredPointsLayer = new GraphicsLayer();
      const locationLayer = new GraphicsLayer();
      map.addMany([pointsLayer, linesLayer, filteredPointsLayer, locationLayer]);

      // UI refs
      const infoPanel = document.getElementById("infoPanel");
      const infoContent = document.getElementById("infoContent");
      const toggleInfo = document.getElementById("toggleInfo");
      const loadingMessage = document.getElementById("loadingMessage");
      const errorMessage = document.getElementById("errorMessage");
      const distritoFilter = document.getElementById("distritoFilter");
      const concelhoFilter = document.getElementById("concelhoFilter");
      const applyFilter = document.getElementById("applyFilter");
      const resetFilter = document.getElementById("resetFilter");
      const toggleFilter = document.getElementById("toggleFilter");
      const filterPanel = document.getElementById("filterPanel");
      const filterLoading = document.getElementById("filterLoading");

      // State
      let allPoints = [];
      let nearest = [];
      const uniqueDistritos = new Set();
      const distritoConcelhoMap = {};

      // Symbols
      const waterPointSymbol = new SimpleMarkerSymbol({
        color: [0, 112, 255, 0.85],
        outline: { color: [80, 220, 255], width: 1 },
        size: 5
      });
      const filteredPointSymbol = new SimpleMarkerSymbol({
        color: [255, 64, 64, 0.9],
        outline: { color: [255, 230, 120], width: 1 },
        size: 6
      });
      const locationSymbol = new SimpleMarkerSymbol({
        color: [0, 200, 0, 0.9],
        outline: { color: [255, 255, 255], width: 2 },
        size: 10
      });
      const lineSymbol = new SimpleLineSymbol({
        color: [255, 0, 0, 0.6],
        width: 1.5,
        style: "short-dash"
      });

      // Error handling function
      function showError(message, duration = 5000) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';
        setTimeout(() => {
          errorMessage.style.display = 'none';
        }, duration);
      }

      // ArcGIS UI
      view.when(() => {
        const basemapGallery = new BasemapGallery({ view: view });
        const bgExpand = new Expand({
          view: view,
          content: basemapGallery,
          expandIconClass: "esri-icon-basemap",
          expandTooltip: "Mudar mapa base"
        });
        view.ui.add(bgExpand, "bottom-right");
        // Auto-close basemap after selection
        basemapGallery.watch("activeBasemap", () => { bgExpand.expanded = false; });

        const searchWidget = new Search({ view });
        view.ui.add(searchWidget, { position: "top-right", index: 1 });

        // Right group: geolocation pin
        const rightGroup = document.createElement("div");
        rightGroup.className = "custom-ui";
        const locateBtn = document.createElement("button");
        locateBtn.innerHTML = "üìç";
        locateBtn.title = "Localizar-me";
        locateBtn.className = "btn-ghost";
        locateBtn.addEventListener("click", () => manualLocate());
        rightGroup.appendChild(locateBtn);
        view.ui.add(rightGroup, { position: "top-right", index: 0 });

        // Left group: reset extent under zoom
        const leftGroup = document.createElement("div");
        leftGroup.className = "custom-ui";
        const resetExtentBtn = document.createElement("button");
        resetExtentBtn.innerHTML = "‚Ü∫";
        resetExtentBtn.title = "Repor extens√£o inicial";
        resetExtentBtn.className = "btn-ghost";
        resetExtentBtn.addEventListener("click", () => view.goTo({ center: [-8, 39.5], zoom: 7 }));
        leftGroup.appendChild(resetExtentBtn);
        view.ui.add(leftGroup, { position: "top-left", index: 1 });

      });

      function manualLocate() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            setLocation(pos.coords.longitude, pos.coords.latitude);
          }, () => {
            showError("N√£o foi poss√≠vel obter a localiza√ß√£o.");
          }, { enableHighAccuracy: true, maximumAge: 30000, timeout: 10000 });
        } else {
          showError("Geolocaliza√ß√£o n√£o suportada.");
        }
      }

      function setLocation(lon, lat) {
        locationLayer.removeAll();
        const point = new Point({ longitude: lon, latitude: lat });
        view.goTo({ target: point, zoom: 14 });
        locationLayer.add(new Graphic({ geometry: point, symbol: locationSymbol }));
      }

      function createPopupContent(attrs) {
        const valid = Object.entries(attrs).filter(([k, v]) => v != null && v !== "");
        valid.sort((a, b) => a[0].localeCompare(b[0]));
        let html = "<table class='info-table'><tbody>";
        for (const [k, v] of valid) {
          const label = k.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
          html += "<tr><th>" + label + "</th><td>" + v + "</td></tr>";
        }
        html += "</tbody></table>";
        return html;
      }

      // WFS ‚Äî use EPSG:4326 to avoid client projection & improve Chrome compatibility
      const wfsUrl = "https://si.icnf.pt/wfs/pontos_agua?service=WFS&version=2.0.0&request=GetFeature&typeNames=pontos_agua&outputFormat=application/json&srsName=EPSG:4326";

      // iOS Chrome (CriOS) has quirks with esri/request/GeoJSONLayer. Use multi-route plain fetch only there.
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
      const isChromeIOS = /CriOS/.test(navigator.userAgent) && isIOS;

      if (isChromeIOS) {
        (async () => {
          const urls = [
            wfsUrl,
            "https://corsproxy.io/?" + encodeURIComponent(wfsUrl)
          ];
          let loaded = false;
          for (const u of urls) {
            try {
              const res = await fetch(u, { cache: "no-store", credentials: "omit" });
              if (!res.ok) continue;
              const txt = await res.text();
              const gj = JSON.parse(txt);
              if (gj && gj.features) {
                ingestFeatures(gj.features);
                loaded = true;
                break;
              }
            } catch (e) {
              console.warn("CriOS fetch falhou:", u, e);
            }
          }
          if (!loaded) {
            try {
              await fallbackGeoJSON();
              loaded = true;
            } catch (e) {
              console.warn("CriOS fallback GeoJSONLayer falhou:", e);
              showError("Falha ao carregar dados. Verifique a conex√£o.");
            }
          }
          loadingMessage.classList.add("hidden");
        })();
      } else {
        // Original path for all other browsers
        loadWFS()
          .catch(() => fallbackGeoJSON())
          .catch(e => {
            console.error("All data loading methods failed:", e);
            showError("N√£o foi poss√≠vel carregar os dados. Tente novamente mais tarde.");
          })
          .finally(() => loadingMessage.classList.add("hidden"));
      }

      function loadWFS() {
        return esriRequest(wfsUrl, {
          responseType: "json"
        }).then(response => {
          const geojson = response.data;
          if (!geojson || !geojson.features) throw new Error("Sem dados GeoJSON v√°lidos.");
          ingestFeatures(geojson.features);
        }).catch(err => {
          console.warn("Falha WFS via esri/request:", err);
          throw err;
        });
      }

      function fallbackGeoJSON() {
        return new Promise((resolve, reject) => {
          try {
            const layer = new GeoJSONLayer({
              url: wfsUrl,
              title: "Pontos de √°gua (WFS ‚Üí GeoJSON)",
              popupTemplate: {
                title: "{nome}",
                content: (e) => createPopupContent(e.graphic.attributes)
              }
            });
            layer.when(() => {
              // Pull graphics for local processing (filters/nearest)
              layer.queryFeatures().then(fs => {
                ingestFeatures(fs.features.map(f => ({
                  geometry: { coordinates: [f.geometry.longitude, f.geometry.latitude] },
                  properties: f.attributes
                })));
                resolve();
              }, reject);
            }, reject);
            map.add(layer);
          } catch (e) {
            console.warn("Falha fallback GeoJSONLayer:", e);
            reject(e);
          }
        });
      }

      function ingestFeatures(features) {
        for (const feat of features) {
          const coords = feat.geometry && feat.geometry.coordinates;
          if (!coords || coords.length < 2) continue;
          const lon = Number(coords[0]), lat = Number(coords[1]);
          const pt = new Point({ longitude: lon, latitude: lat });
          const g = new Graphic({
            geometry: pt,
            attributes: feat.properties || {},
            symbol: waterPointSymbol,
            popupTemplate: {
              title: (feat.properties && (feat.properties.nome || feat.properties.tipologia)) || "Ponto de √°gua",
              content: createPopupContent(feat.properties || {})
            }
          });
          allPoints.push(g);
          pointsLayer.add(g);

          // Build filters
          const distrito = (feat.properties && feat.properties.distrito) || "Desconhecido";
          const concelho = (feat.properties && feat.properties.concelho) || "Desconhecido";
          uniqueDistritos.add(distrito);
          if (!distritoConcelhoMap[distrito]) distritoConcelhoMap[distrito] = new Set();
          distritoConcelhoMap[distrito].add(concelho);
        }
        // Populate selects
        for (const d of Array.from(uniqueDistritos).sort()) {
          distritoFilter.appendChild(new Option(d, d));
        }
        // Initial nearest computation once features ready
        if (view.center) findNearest(view.center);
      }

      // Filtering
      distritoFilter.addEventListener("change", function () {
        const sel = this.value;
        concelhoFilter.innerHTML = '<option value="">Todos os concelhos</option>';
        if (sel && distritoConcelhoMap[sel]) {
          Array.from(distritoConcelhoMap[sel]).sort().forEach(c => {
            concelhoFilter.appendChild(new Option(c, c));
          });
        }
      });

      applyFilter.addEventListener("click", function () {
        filterLoading.classList.remove("hidden");
        
        // Use setTimeout to allow the UI to update before heavy processing
        setTimeout(() => {
          const distrito = distritoFilter.value;
          const concelho = concelhoFilter.value;
          pointsLayer.removeAll();
          filteredPointsLayer.removeAll();
          for (const g of allPoints) {
            const a = g.attributes || {};
            const matchD = !distrito || a.distrito === distrito;
            const matchC = !concelho || a.concelho === concelho;
            if (matchD && matchC) {
              const fg = g.clone();
              fg.symbol = filteredPointSymbol;
              filteredPointsLayer.add(fg);
            }
          }
          // Zoom to filtered graphics if any and refresh nearest box
          const sel = filteredPointsLayer.graphics.items;
          if (sel.length) {
            fitToGraphics(sel, 60);
          }
          if (view.center) findNearest(view.center);
          
          filterLoading.classList.add("hidden");
        }, 100);
      });

      resetFilter.addEventListener("click", function () {
        distritoFilter.value = "";
        concelhoFilter.value = "";
        concelhoFilter.innerHTML = '<option value="">Todos os concelhos</option>';
        pointsLayer.removeAll();
        filteredPointsLayer.removeAll();
        for (const g of allPoints) pointsLayer.add(g);
        const all = pointsLayer.graphics.items;
        if (all.length) {
          fitToGraphics(all, 60);
        }
        if (view.center) findNearest(view.center);
      });

      
      function fitToGraphics(graphics, padding = 40) {
        if (!graphics || !graphics.length) return;
        let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
        for (const g of graphics) {
          const geom = g.geometry;
          if (!geom) continue;
          const x = geom.longitude ?? geom.x;
          const y = geom.latitude ?? geom.y;
          if (typeof x !== 'number' || typeof y !== 'number') continue;
          if (x < xmin) xmin = x;
          if (y < ymin) ymin = y;
          if (x > xmax) xmax = x;
          if (y > ymax) ymax = y;
        }
        if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return;
        const ext = new Extent({ xmin, ymin, xmax, ymax, spatialReference: { wkid: 4326 } });
        view.goTo({ target: ext, padding }).catch(() => {});
      }

      // Panels collapse/expand
      function togglePanel(panel, btn) {
        const collapsed = panel.dataset.state === "collapsed";
        if (collapsed) {
          panel.dataset.state = "expanded";
          panel.style.maxHeight = "50%";
          panel.style.opacity = "1";
          panel.style.transform = "translateY(0)";
          btn.textContent = btn.id === "toggleInfo" ? "üìã" : "‚öôÔ∏è";
        } else {
          panel.dataset.state = "collapsed";
          panel.style.maxHeight = "24px";
          panel.style.opacity = "0.7";
          panel.style.transform = "translateY(0)";
          btn.textContent = "‚ñ∂";
        }
      }
      toggleInfo.addEventListener("click", () => togglePanel(infoPanel, toggleInfo));
      toggleFilter.addEventListener("click", () => togglePanel(filterPanel, toggleFilter));
      // Start collapsed on small screens
      const smallScreen = Math.max(window.innerWidth, window.innerHeight) < 700;
      if (smallScreen) {
        togglePanel(infoPanel, toggleInfo);
        togglePanel(filterPanel, toggleFilter);
      }

      // Throttled & debounced nearest computation for better perf on Chrome mobile
      let lastMove = 0;
      const MOVE_THROTTLE_MS = 200; // Increased from 100ms to 200ms for better mobile performance
      function onMove(e){
        const now = performance.now();
        if (now - lastMove < MOVE_THROTTLE_MS) return;
        lastMove = now;
        const pt = view.toMap({ x: e.x, y: e.y });
        if (pt) findNearest(pt);
      }
      view.on("pointer-move", onMove);
      view.on("pointer-down", onMove);
      view.on("pointer-up", onMove);
      view.on("drag", (e) => {
        // while dragging, recompute using center to ensure feedback
        const pt = view.center && view.center.clone();
        if (pt) findNearest(pt);
      });

      // Debounce helper
      function debounce(fn, wait){
        let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); };
      }
      const centerWatchHandler = debounce(() => {
        if (view.center) findNearest(view.center);
      }, 300); // Increased from 200ms to 300ms for better mobile performance

      view.watch("center", centerWatchHandler);
      view.watch("stationary", (s) => { if (s && view.center) findNearest(view.center); });
      view.on("click", (e) => { const pt = view.toMap(e); if (pt) findNearest(pt); });

      // Optimized distance calculation with spatial partitioning for better mobile performance
      let spatialGrid = {};
      
      function buildSpatialGrid(points, gridSize = 0.5) {
        // Clear previous grid
        spatialGrid = {};
        
        for (const point of points) {
          const geom = point.geometry;
          if (!geom) continue;
          
          const lon = geom.longitude;
          const lat = geom.latitude;
          
          const gridX = Math.floor(lon / gridSize);
          const gridY = Math.floor(lat / gridSize);
          const gridKey = `${gridX},${gridY}`;
          
          if (!spatialGrid[gridKey]) {
            spatialGrid[gridKey] = [];
          }
          
          spatialGrid[gridKey].push(point);
        }
      }
      
      function metersDistance(a, b) {
        // Pure Haversine (geodesic) to avoid geometry engine issues
        const R = 6371000;
        const toRad = d => d * Math.PI / 180;
        const dLat = toRad(b.latitude - a.latitude);
        const dLon = toRad(b.longitude - a.longitude);
        const lat1 = toRad(a.latitude), lat2 = toRad(b.latitude);
        const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        return Math.round(2 * R * Math.asin(Math.sqrt(s)));
      }

      function findNearest(pt) {
        if (!allPoints.length) return;
        linesLayer.removeAll();

        // Use spatial grid for faster searching on mobile
        if (Object.keys(spatialGrid).length === 0) {
          buildSpatialGrid(allPoints);
        }

        const active = filteredPointsLayer.graphics.length ? filteredPointsLayer.graphics.items : allPoints;
        
        // First check the grid cell where the point is located and adjacent cells
        const gridSize = 0.5;
        const gridX = Math.floor(pt.longitude / gridSize);
        const gridY = Math.floor(pt.latitude / gridSize);
        
        let candidates = [];
        const searchRadius = 2; // Check adjacent cells in a 5x5 grid
        
        for (let x = gridX - searchRadius; x <= gridX + searchRadius; x++) {
          for (let y = gridY - searchRadius; y <= gridY + searchRadius; y++) {
            const gridKey = `${x},${y}`;
            if (spatialGrid[gridKey]) {
              for (const g of spatialGrid[gridKey]) {
                // Only include points that are in the active set
                if (active.includes(g)) {
                  candidates.push({
                    feature: g,
                    distance: metersDistance(pt, g.geometry)
                  });
                }
              }
            }
          }
        }

        // If we didn't find enough points in the nearby grid cells, fall back to full search
        if (candidates.length < 4) {
          candidates = active.map(g => ({
            feature: g,
            distance: metersDistance(pt, g.geometry)
          }));
        }

        nearest = candidates
          .filter(o => o.distance <= 10000)
          .sort((a, b) => a.distance - b.distance)
          .slice(0, 4);

        for (const item of nearest) {
          const line = new Polyline({
            paths: [[pt.longitude, pt.latitude], [item.feature.geometry.longitude, item.feature.geometry.latitude]],
            spatialReference: { wkid: 4326 }
          });
          linesLayer.add(new Graphic({ geometry: line, symbol: lineSymbol }));
        }
        renderInfo();
      }

      function renderInfo() {
        let html = "<h4 style='margin:4px 0 6px'>Pontos de √°gua mais pr√≥ximos <small>(at√© 10 km)</small>:</h4>";
        if (!nearest.length) {
          html += "<p style='margin:0'>Nenhum ponto encontrado.</p>";
        } else {
          html += "<ul style='margin:0; padding-left: 16px; font-size: 12px;'>";
          for (const o of nearest) {
            const a = o.feature.attributes || {};
            const name = a.nome || "Sem nome";
            const type = a.tipologia ? (" (" + a.tipologia + ")") : "";
            html += "<li>" + name + type + " ‚Äî " + o.distance + " m</li>";
          }
          html += "</ul>";
        }
        infoContent.innerHTML = html;
      }

      // Build spatial grid when data is loaded
      setTimeout(() => {
        if (allPoints.length > 0) {
          buildSpatialGrid(allPoints);
        }
      }, 2000);

      // Robust error reporting (in case both loaders fail)
      window.addEventListener("unhandledrejection", (e) => {
        console.warn("Unhandled rejection:", e.reason);
        showError("Ocorreu um erro inesperado. Recarregue a p√°gina.");
      });
    });
  </script>
</body>
</html>