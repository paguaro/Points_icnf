<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <title>Pontos de √°gua ICNF</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="https://js.arcgis.com/4.33/esri/themes/light/main.css" />

  <style>
    html, body, #viewDiv {
      margin: 0; padding: 0; height: 100%; width: 100%;
      -webkit-text-size-adjust: 100%;
    }

    .esri-ui .esri-widget, .esri-ui button, .esri-ui input, .esri-ui select {
      font-size: 12px;
      line-height: 1.2;
    }

    #infoPanel, #filterPanel, #firePanel {
      position: absolute;
      background: #fff;
      padding: 6px 8px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,.15);
      font-size: 8px;
      z-index: 10;
      max-height: 50%;
      overflow-y: auto;
      transition: max-height .25s ease, opacity .25s ease, transform .25s ease;
      will-change: max-height, opacity, transform;
      backdrop-filter: saturate(120%) blur(2px);
    }
    #infoPanel { top: 110px; right: 10px; width: min(260px, 42vw); }
    #filterPanel { top: 130px; left: 10px; width: min(160px, 28vw); overflow: hidden; }
    #firePanel { 
      top: 170px; 
      right: 10px; 
      width: min(300px, 50vw); 
      max-height: 60%; 
      display: none; 
    }

    .toggle-chip {
      position: absolute;
      top: 4px;
      left: 4px;
      background: #f2f2f2;
      border: 1px solid #ddd;
      cursor: pointer;
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 14px;
      line-height: 1.1;
      user-select: none;
    }

    #toggleFirePanel {
      position: absolute;
      top: 4px;
      right: 4px;
      background: #f2f2f2;
      border: 1px solid #ddd;
      cursor: pointer;
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 14px;
      line-height: 1.1;
      user-select: none;
    }

    #loadingMessage {
      position: absolute; inset: 0;
      display: grid; place-items: center;
      pointer-events: none;
      z-index: 1000;
    }
    #loadingBox {
      background: #fff;
      padding: 12px 14px;
      border-radius: 10px;
      box-shadow: 0 4px 16px rgba(0,0,0,.2);
      font-size: 14px;
    }

    #errorMessage {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: #d32f2f;
      color: white;
      padding: 12px 16px;
      border-radius: 6px;
      z-index: 1001;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      display: none;
      max-width: 80%;
      text-align: center;
      font-size: 14px;
    }

    select, button {
      width: 100%;
      padding: 8px 10px;
      margin: 4px 0;
      box-sizing: border-box;
      font-size: 12px;
      border-radius: 8px;
    }
    button {
      background-color: #0079c1; color: #fff; border: none; cursor: pointer;
    }
    button:hover { background-color: #005a8c; }
    .btn-ghost {
      background: #fff; color: #000; border: 1px solid #ccc;
    }

    .hidden { display: none !important; }

    .info-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }
    .info-table th, .info-table td {
      text-align: left;
      padding: 2px 4px;
      border-bottom: 1px dotted #eee;
      vertical-align: top;
      word-break: break-word;
    }
    .info-table th {
      width: 40%;
      color: #444;
      font-weight: 600;
    }

    .custom-ui {
      display: flex; gap: 6px;
      align-items: center;
      background: transparent;
      border: 0;
      padding: 0;
    }
    .custom-ui button {
      width: auto;
      min-width: 36px;
      padding: 8px;
    }

    .esri-view { touch-action: pan-x pan-y; }

    .filter-loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid #f3f3f3;
      border-top: 2px solid #0079c1;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 8px;
      vertical-align: middle;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #fireHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      padding-bottom: 4px;
      border-bottom: 1px solid #eee;
    }
    
    #fireControls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 8px;
    }
    
    .fire-control-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    
    .fire-control-row label {
      font-size: 12px;
      white-space: nowrap;
    }
    
    .fire-control-row select {
      flex: 1;
    }
    
    #firePlayer {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }
    
    #fireDateDisplay {
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      font-weight: bold;
    }
    
    #fireProgress {
      flex: 1;
      height: 6px;
      background: #eee;
      border-radius: 3px;
      overflow: hidden;
    }
    
    #fireProgressBar {
      height: 100%;
      background: #ff5722;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .fire-player-btn {
      background: none;
      border: none;
      font-size: 16px;
      cursor: pointer;
      color: #0079c1;
      padding: 4px;
    }
    
    .fire-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
      font-size: 10px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    #corsWarning {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #ff9800;
      color: white;
      padding: 20px;
      border-radius: 8px;
      z-index: 1002;
      text-align: center;
      max-width: 80%;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      display: none;
    }
  </style>
</head>
<body>
  <div id="viewDiv"></div>
  <div id="infoPanel" aria-live="polite">
    <button id="toggleInfo" class="toggle-chip" title="Minimizar / Expandir">üìã</button>
    <div id="infoContent"></div>
    <button id="toggleFirePanel" title="Mostrar dados de inc√™ndios">üî•</button>
  </div>

  <div id="filterPanel">
    <button id="toggleFilter" class="toggle-chip" title="Minimizar / Expandir">‚öôÔ∏è</button>
    <strong style="display:block; margin-left: 22px; margin-bottom: 4px; font-size:8px;">Filtrar</strong>
    <select id="distritoFilter" aria-label="Filtrar por distrito">
      <option value="">Todos os distritos</option>
    </select>
    <select id="concelhoFilter" aria-label="Filtrar por concelho">
      <option value="">Todos os concelhos</option>
    </select>
    <div class="custom-ui">
      <button id="applyFilter">Aplicar</button>
      <button id="resetFilter" class="btn-ghost">Repor</button>
    </div>
    <div id="filterLoading" class="filter-loading hidden"></div>
  </div>

  <div id="firePanel">
    <div id="fireHeader">
      <h3 style="margin: 0; font-size: 14px;">Atividade de Inc√™ndios</h3>
      <button id="closeFirePanel" class="fire-player-btn" title="Fechar">‚úï</button>
    </div>
    <div id="fireControls">
      <div class="fire-control-row">
        <label for="fireRegion">Regi√£o:</label>
        <select id="fireRegion">
          <option value="iberian_peninsula">Pen√≠nsula Ib√©rica</option>
          <option value="europe">Europa</option>
          <option value="global">Global</option>
        </select>
      </div>
      <div class="fire-control-row">
        <label for="fireDays">Dias a mostrar:</label>
        <select id="fireDays">
          <option value="3">3 dias</option>
          <option value="5" selected>5 dias</option>
          <option value="7">7 dias</option>
          <option value="10">10 dias</option>
        </select>
      </div>
    </div>
    <div id="fireDateDisplay">Carregando dados...</div>
    <div id="firePlayer">
      <button id="firePrev" class="fire-player-btn" title="Dia anterior">‚èÆ</button>
      <button id="firePlayPause" class="fire-player-btn" title="Reproduzir/Pausar">‚ñ∂</button>
      <button id="fireNext" class="fire-player-btn" title="Pr√≥ximo dia">‚è≠</button>
      <div id="fireProgress">
        <div id="fireProgressBar"></div>
      </div>
    </div>
    <div class="fire-legend">
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ffeb3b;"></div>
        <span>Baixa intensidade</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #ff9800;"></div>
        <span>M√©dia intensidade</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background-color: #f44336;"></div>
        <span>Alta intensidade</span>
      </div>
    </div>
  </div>

  <div id="loadingMessage">
    <div id="loadingBox">A carregar dados WFS‚Ä¶</div>
  </div>

  <div id="errorMessage"></div>

  <div id="corsWarning">
    <h3>Aviso: Problema de CORS</h3>
    <p>Alguns dados de inc√™ndio podem n√£o carregar devido a restri√ß√µes de seguran√ßa do navegador.</p>
    <p>Para uma experi√™ncia completa, considere hospedar esta aplica√ß√£o em um servidor web.</p>
    <button onclick="document.getElementById('corsWarning').style.display='none'">Fechar</button>
  </div>

  <script src="https://js.arcgis.com/4.33/"></script>
  <script>
    require([
      "esri/config",
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/geometry/Point",
      "esri/geometry/Polyline",
      "esri/geometry/Extent",
      "esri/geometry/geometryEngine",
      "esri/symbols/SimpleMarkerSymbol",
      "esri/symbols/SimpleLineSymbol",
      "esri/widgets/BasemapGallery",
      "esri/widgets/Expand",
      "esri/widgets/Search",
      "esri/request",
      "esri/layers/GeoJSONLayer",
      "esri/layers/FeatureLayer"
    ], function(esriConfig, Map, MapView, GraphicsLayer, Graphic, Point, Polyline, Extent, geometryEngine, SimpleMarkerSymbol, SimpleLineSymbol, BasemapGallery, Expand, Search, esriRequest, GeoJSONLayer, FeatureLayer) {

      // Configurazione CORS migliorata
      try {
        esriConfig.request = esriConfig.request || {};
        esriConfig.request.corsEnabledServers = esriConfig.request.corsEnabledServers || [];
        esriConfig.request.trustedServers = esriConfig.request.trustedServers || [];
        
        const servers = ["si.icnf.pt", "https://si.icnf.pt", "services9.arcgis.com"];
        servers.forEach(host => {
          if (!esriConfig.request.corsEnabledServers.includes(host)) {
            esriConfig.request.corsEnabledServers.push(host);
          }
          if (!esriConfig.request.trustedServers.includes(host)) {
            esriConfig.request.trustedServers.push(host);
          }
        });
        
        esriConfig.request.timeout = 30000;
        esriConfig.request.useCors = true;
        
      } catch (e) {
        console.warn("CORS configuration error:", e);
      }

      const map = new Map({ basemap: "streets-navigation-vector" });
      const view = new MapView({
        container: "viewDiv",
        map,
        center: [-8, 39.5],
        zoom: 7,
        popupEnabled: true
      });

      // Layers
      const pointsLayer = new GraphicsLayer();
      const linesLayer = new GraphicsLayer();
      const filteredPointsLayer = new GraphicsLayer();
      const locationLayer = new GraphicsLayer();
      const fireLayer = new GraphicsLayer();
      map.addMany([pointsLayer, linesLayer, filteredPointsLayer, locationLayer, fireLayer]);

      // UI refs
      const infoPanel = document.getElementById("infoPanel");
      const infoContent = document.getElementById("infoContent");
      const toggleInfo = document.getElementById("toggleInfo");
      const loadingMessage = document.getElementById("loadingMessage");
      const errorMessage = document.getElementById("errorMessage");
      const distritoFilter = document.getElementById("distritoFilter");
      const concelhoFilter = document.getElementById("concelhoFilter");
      const applyFilter = document.getElementById("applyFilter");
      const resetFilter = document.getElementById("resetFilter");
      const toggleFilter = document.getElementById("toggleFilter");
      const filterPanel = document.getElementById("filterPanel");
      const filterLoading = document.getElementById("filterLoading");
      
      // Fire panel elements
      const toggleFirePanel = document.getElementById("toggleFirePanel");
      const firePanel = document.getElementById("firePanel");
      const closeFirePanel = document.getElementById("closeFirePanel");
      const fireRegion = document.getElementById("fireRegion");
      const fireDays = document.getElementById("fireDays");
      const fireDateDisplay = document.getElementById("fireDateDisplay");
      const firePrev = document.getElementById("firePrev");
      const firePlayPause = document.getElementById("firePlayPause");
      const fireNext = document.getElementById("fireNext");
      const fireProgressBar = document.getElementById("fireProgressBar");

      // State
      let allPoints = [];
      let nearest = [];
      const uniqueDistritos = new Set();
      const distritoConcelhoMap = {};
      
      // Fire data state
      let fireData = [];
      let currentFireDateIndex = 0;
      let fireAnimationInterval = null;
      let isFirePanelOpen = false;

      // Symbols
      const waterPointSymbol = new SimpleMarkerSymbol({
        color: [0, 112, 255, 0.85],
        outline: { color: [80, 220, 255], width: 1 },
        size: 5
      });
      const filteredPointSymbol = new SimpleMarkerSymbol({
        color: [255, 64, 64, 0.9],
        outline: { color: [255, 230, 120], width: 1 },
        size: 6
      });
      const locationSymbol = new SimpleMarkerSymbol({
        color: [0, 200, 0, 0.9],
        outline: { color: [255, 255, 255], width: 2 },
        size: 10
      });
      const lineSymbol = new SimpleLineSymbol({
        color: [255, 0, 0, 0.6],
        width: 1.5,
        style: "short-dash"
      });
      
      // Fire symbols based on intensity (frp)
      const lowFireSymbol = new SimpleMarkerSymbol({
        color: [255, 235, 59, 0.7],
        outline: { color: [255, 255, 255, 0.8], width: 1 },
        size: 6
      });
      
      const mediumFireSymbol = new SimpleMarkerSymbol({
        color: [255, 152, 0, 0.7],
        outline: { color: [255, 255, 255, 0.8], width: 1 },
        size: 8
      });
      
      const highFireSymbol = new SimpleMarkerSymbol({
        color: [244, 67, 54, 0.7],
        outline: { color: [255, 255, 255, 0.8], width: 1 },
        size: 10
      });

      // Error handling function
      function showError(message, duration = 5000) {
        errorMessage.textContent = message;
        errorMessage.style.display = 'block';
        setTimeout(() => {
          errorMessage.style.display = 'none';
        }, duration);
      }

      // ArcGIS UI
      view.when(() => {
        const basemapGallery = new BasemapGallery({ view: view });
        const bgExpand = new Expand({
          view: view,
          content: basemapGallery,
          expandIconClass: "esri-icon-basemap",
          expandTooltip: "Mudar mapa base"
        });
        view.ui.add(bgExpand, "bottom-right");
        // Auto-close basemap after selection
        basemapGallery.watch("activeBasemap", () => { bgExpand.expanded = false; });

        const searchWidget = new Search({ view });
        view.ui.add(searchWidget, { position: "top-right", index: 1 });

        // Right group: geolocation pin
        const rightGroup = document.createElement("div");
        rightGroup.className = "custom-ui";
        const locateBtn = document.createElement("button");
        locateBtn.innerHTML = "üìç";
        locateBtn.title = "Localizar-me";
        locateBtn.className = "btn-ghost";
        locateBtn.addEventListener("click", () => manualLocate());
        rightGroup.appendChild(locateBtn);
        view.ui.add(rightGroup, { position: "top-right", index: 0 });

        // Left group: reset extent under zoom
        const leftGroup = document.createElement("div");
        leftGroup.className = "custom-ui";
        const resetExtentBtn = document.createElement("button");
        resetExtentBtn.innerHTML = "‚Ü∫";
        resetExtentBtn.title = "Repor extens√£o inicial";
        resetExtentBtn.className = "btn-ghost";
        resetExtentBtn.addEventListener("click", () => view.goTo({ center: [-8, 39.5], zoom: 7 }));
        leftGroup.appendChild(resetExtentBtn);
        view.ui.add(leftGroup, { position: "top-left", index: 1 });

      });

      function manualLocate() {
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            setLocation(pos.coords.longitude, pos.coords.latitude);
          }, () => {
            showError("N√£o foi poss√≠vel obter a localiza√ß√£o.");
          }, { enableHighAccuracy: true, maximumAge: 30000, timeout: 10000 });
        } else {
          showError("Geolocaliza√ß√£o n√£o suportada.");
        }
      }

      function setLocation(lon, lat) {
        locationLayer.removeAll();
        const point = new Point({ longitude: lon, latitude: lat });
        view.goTo({ target: point, zoom: 14 });
        locationLayer.add(new Graphic({ geometry: point, symbol: locationSymbol }));
      }

      function createPopupContent(attrs) {
        const valid = Object.entries(attrs).filter(([k, v]) => v != null && v !== "");
        valid.sort((a, b) => a[0].localeCompare(b[0]));
        let html = "<table class='info-table'><tbody>";
        for (const [k, v] of valid) {
          const label = k.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
          html += "<tr><th>" + label + "</th><td>" + v + "</td></tr>";
        }
        html += "</tbody></table>";
        return html;
      }

      // WFS ‚Äî use EPSG:4326 to avoid client projection & improve Chrome compatibility
      const wfsUrl = "https://si.icnf.pt/wfs/pontos_agua?service=WFS&version=2.0.0&request=GetFeature&typeNames=pontos_agua&outputFormat=application/json&srsName=EPSG:4326";

      // Fire service URL - CORRETTO
      const fireServiceUrl = "https://services9.arcgis.com/RHVPKKiFTONKtxq3/arcgis/rest/services/Satellite_VIIRS_Thermal_Hotspots_and_Fire_Activity/FeatureServer/0";

      // iOS Chrome (CriOS) has quirks with esri/request/GeoJSONLayer. Use multi-route plain fetch only there.
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
      const isChromeIOS = /CriOS/.test(navigator.userAgent) && isIOS;

      if (isChromeIOS) {
        (async () => {
          const urls = [
            wfsUrl,
            "https://corsproxy.io/?" + encodeURIComponent(wfsUrl)
          ];
          let loaded = false;
          for (const u of urls) {
            try {
              const res = await fetch(u, { cache: "no-store", credentials: "omit" });
              if (!res.ok) continue;
              const txt = await res.text();
              const gj = JSON.parse(txt);
              if (gj && gj.features) {
                ingestFeatures(gj.features);
                loaded = true;
                break;
              }
            } catch (e) {
              console.warn("CriOS fetch falhou:", u, e);
            }
          }
          if (!loaded) {
            try {
              await fallbackGeoJSON();
              loaded = true;
            } catch (e) {
              console.warn("CriOS fallback GeoJSONLayer falhou:", e);
              showError("Falha ao carregar dados. Verifique a conex√£o.");
            }
          }
          loadingMessage.classList.add("hidden");
        })();
      } else {
        // Original path for all other browsers
        loadWFS()
          .catch(() => fallbackGeoJSON())
          .catch(e => {
            console.error("All data loading methods failed:", e);
            showError("N√£o foi poss√≠vel carregar os dados. Tente novamente mais tarde.");
          })
          .finally(() => loadingMessage.classList.add("hidden"));
      }

      function loadWFS() {
        return esriRequest(wfsUrl, {
          responseType: "json",
          query: {}
        }).then(response => {
          const geojson = response.data;
          if (!geojson || !geojson.features) throw new Error("Sem dados GeoJSON v√°lidos.");
          ingestFeatures(geojson.features);
        }).catch(err => {
          console.warn("Falha WFS via esri/request:", err);
          throw err;
        });
      }

      function fallbackGeoJSON() {
        return new Promise((resolve, reject) => {
          try {
            const layer = new GeoJSONLayer({
              url: wfsUrl,
              title: "Pontos de √°gua (WFS ‚Üí GeoJSON)",
              popupTemplate: {
                title: "{nome}",
                content: (e) => createPopupContent(e.graphic.attributes)
              }
            });
            layer.when(() => {
              // Pull graphics for local processing (filters/nearest)
              layer.queryFeatures().then(fs => {
                ingestFeatures(fs.features.map(f => ({
                  geometry: { coordinates: [f.geometry.longitude, f.geometry.latitude] },
                  properties: f.attributes
                })));
                resolve();
              }, reject);
            }, reject);
            map.add(layer);
          } catch (e) {
            console.warn("Falha fallback GeoJSONLayer:", e);
            reject(e);
          }
        });
      }

      function ingestFeatures(features) {
        for (const feat of features) {
          const coords = feat.geometry && feat.geometry.coordinates;
          if (!coords || coords.length < 2) continue;
          const lon = Number(coords[0]), lat = Number(coords[1]);
          const pt = new Point({ longitude: lon, latitude: lat });
          const g = new Graphic({
            geometry: pt,
            attributes: feat.properties || {},
            symbol: waterPointSymbol,
            popupTemplate: {
              title: (feat.properties && (feat.properties.nome || feat.properties.tipologia)) || "Ponto de √°gua",
              content: function (event) {
                var g = event.graphic;
                var geom = g.geometry;
                var attrs = g.attributes || {};
                var lat = Number(geom.latitude).toFixed(6);
                var lon = Number(geom.longitude).toFixed(6);
                var wazeUrl  = "https://waze.com/ul?ll=" + lat + "%2C" + lon + "&navigate=yes&zoom=17";
                var gmapsUrl = "https://www.google.com/maps/dir/?api=1&destination=" + lat + "," + lon + "";
                var infoHtml = createPopupContent(attrs);
                var linksHtml = "<div style='margin-top:8px; display:flex; gap:10px; align-items:center;'>"
                  + "<a href='" + wazeUrl + "' target='_blank' rel='noopener noreferrer'>Waze</a>"
                  + "<a href='" + gmapsUrl + "' target='_blank' rel='noopener noreferrer' style='margin-left:8px;'>Google</a>"
                  + "</div>";
                return infoHtml + linksHtml;
              }
            }
          });
          allPoints.push(g);
          pointsLayer.add(g);

          // Build filters
          const distrito = (feat.properties && feat.properties.distrito) || "Desconhecido";
          const concelho = (feat.properties && feat.properties.concelho) || "Desconhecido";
          uniqueDistritos.add(distrito);
          if (!distritoConcelhoMap[distrito]) distritoConcelhoMap[distrito] = new Set();
          distritoConcelhoMap[distrito].add(concelho);
        }
        // Populate selects
        for (const d of Array.from(uniqueDistritos).sort()) {
          distritoFilter.appendChild(new Option(d, d));
        }
        // Initial nearest computation once features ready
        if (view.center) findNearest(view.center);
      }

      // Filtering
      distritoFilter.addEventListener("change", function () {
        const sel = this.value;
        concelhoFilter.innerHTML = '<option value="">Todos os concelhos</option>';
        if (sel && distritoConcelhoMap[sel]) {
          Array.from(distritoConcelhoMap[sel]).sort().forEach(c => {
            concelhoFilter.appendChild(new Option(c, c));
          });
        }
      });

      applyFilter.addEventListener("click", function () {
        filterLoading.classList.remove("hidden");
        
        // Use setTimeout to allow the UI to update before heavy processing
        setTimeout(() => {
          const distrito = distritoFilter.value;
          const concelho = concelhoFilter.value;
          pointsLayer.removeAll();
          filteredPointsLayer.removeAll();
          for (const g of allPoints) {
            const a = g.attributes || {};
            const matchD = !distrito || a.distrito === distrito;
            const matchC = !concelho || a.concelho === concelho;
            if (matchD && matchC) {
              const fg = g.clone();
              fg.symbol = filteredPointSymbol;
              filteredPointsLayer.add(fg);
            }
          }
          // Zoom to filtered graphics if any and refresh nearest box
          const sel = filteredPointsLayer.graphics.items;
          if (sel.length) {
            fitToGraphics(sel, 60);
          }
          if (view.center) findNearest(view.center);
          
          filterLoading.classList.add("hidden");
        }, 100);
      });

      resetFilter.addEventListener("click", function () {
        distritoFilter.value = "";
        concelhoFilter.value = "";
        concelhoFilter.innerHTML = '<option value="">Todos os concelhos</option>';
        pointsLayer.removeAll();
        filteredPointsLayer.removeAll();
        for (const g of allPoints) pointsLayer.add(g);
        const all = pointsLayer.graphics.items;
        if (all.length) {
          fitToGraphics(all, 60);
        }
        if (view.center) findNearest(view.center);
      });

      
      function fitToGraphics(graphics, padding = 40) {
        if (!graphics || !graphics.length) return;
        let xmin = Infinity, ymin = Infinity, xmax = -Infinity, ymax = -Infinity;
        for (const g of graphics) {
          const geom = g.geometry;
          if (!geom) continue;
          const x = geom.longitude ?? geom.x;
          const y = geom.latitude ?? geom.y;
          if (typeof x !== 'number' || typeof y !== 'number') continue;
          if (x < xmin) xmin = x;
          if (y < ymin) ymin = y;
          if (x > xmax) xmax = x;
          if (y > ymax) ymax = y;
        }
        if (!isFinite(xmin) || !isFinite(ymin) || !isFinite(xmax) || !isFinite(ymax)) return;
        const ext = new Extent({ xmin, ymin, xmax, ymax, spatialReference: { wkid: 4326 } });
        view.goTo({ target: ext, padding }).catch(() => {});
      }

      // Panels collapse/expand
      function togglePanel(panel, btn) {
        const collapsed = panel.dataset.state === "collapsed";
        if (collapsed) {
          panel.dataset.state = "expanded";
          panel.style.maxHeight = "50%";
          panel.style.opacity = "1";
          panel.style.transform = "translateY(0)";
          btn.textContent = btn.id === "toggleInfo" ? "üìã" : "‚öôÔ∏è";
        } else {
          panel.dataset.state = "collapsed";
          panel.style.maxHeight = "24px";
          panel.style.opacity = "0.7";
          panel.style.transform = "translateY(0)";
          btn.textContent = "‚ñ∂";
        }
      }
      toggleInfo.addEventListener("click", () => togglePanel(infoPanel, toggleInfo));
      toggleFilter.addEventListener("click", () => togglePanel(filterPanel, toggleFilter));
      
      // Fire panel toggle
      toggleFirePanel.addEventListener("click", () => {
        if (isFirePanelOpen) {
          firePanel.style.display = "none";
          isFirePanelOpen = false;
        } else {
          firePanel.style.display = "block";
          isFirePanelOpen = true;
          // Load fire data if not already loaded
          if (fireData.length === 0) {
            loadFireData();
          }
        }
      });
      
      closeFirePanel.addEventListener("click", () => {
        firePanel.style.display = "none";
        isFirePanelOpen = false;
        stopFireAnimation();
      });
      
      // Start collapsed on small screens
      const smallScreen = Math.max(window.innerWidth, window.innerHeight) < 700;
      if (smallScreen) {
        togglePanel(infoPanel, toggleInfo);
        togglePanel(filterPanel, toggleFilter);
      }

      // Throttled & debounced nearest computation for better perf on Chrome mobile
      let lastMove = 0;
      const MOVE_THROTTLE_MS = 200;
      function onMove(e){
        const now = performance.now();
        if (now - lastMove < MOVE_THROTTLE_MS) return;
        lastMove = now;
        const pt = view.toMap({ x: e.x, y: e.y });
        if (pt) findNearest(pt);
      }
      view.on("pointer-move", onMove);
      view.on("pointer-down", onMove);
      view.on("pointer-up", onMove);
      view.on("drag", (e) => {
        // while dragging, recompute using center to ensure feedback
        const pt = view.center && view.center.clone();
        if (pt) findNearest(pt);
      });

      // Debounce helper
      function debounce(fn, wait){
        let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); };
      }
      const centerWatchHandler = debounce(() => {
        if (view.center) findNearest(view.center);
      }, 300);

      view.watch("center", centerWatchHandler);
      view.watch("stationary", (s) => { if (s && view.center) findNearest(view.center); });
      view.on("click", (e) => { const pt = view.toMap(e); if (pt) findNearest(pt); });

      // Optimized distance calculation with spatial partitioning for better mobile performance
      let spatialGrid = {};
      
      function buildSpatialGrid(points, gridSize = 0.5) {
        // Clear previous grid
        spatialGrid = {};
        
        for (const point of points) {
          const geom = point.geometry;
          if (!geom) continue;
          
          const lon = geom.longitude;
          const lat = geom.latitude;
          
          const gridX = Math.floor(lon / gridSize);
          const gridY = Math.floor(lat / gridSize);
          const gridKey = `${gridX},${gridY}`;
          
          if (!spatialGrid[gridKey]) {
            spatialGrid[gridKey] = [];
          }
          
          spatialGrid[gridKey].push(point);
        }
      }
      
      function metersDistance(a, b) {
        // Pure Haversine (geodesic) to avoid geometry engine issues
        const R = 6371000;
        const toRad = d => d * Math.PI / 180;
        const dLat = toRad(b.latitude - a.latitude);
        const dLon = toRad(b.longitude - a.longitude);
        const lat1 = toRad(a.latitude), lat2 = toRad(b.latitude);
        const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
        return Math.round(2 * R * Math.asin(Math.sqrt(s)));
      }

      function findNearest(pt) {
        if (!allPoints.length) return;
        linesLayer.removeAll();

        // Use spatial grid for faster searching on mobile
        if (Object.keys(spatialGrid).length === 0) {
          buildSpatialGrid(allPoints);
        }

        const active = filteredPointsLayer.graphics.length ? filteredPointsLayer.graphics.items : allPoints;
        
        // First check the grid cell where the point is located and adjacent cells
        const gridSize = 0.5;
        const gridX = Math.floor(pt.longitude / gridSize);
        const gridY = Math.floor(pt.latitude / gridSize);
        
        let candidates = [];
        const searchRadius = 2; // Check adjacent cells in a 5x5 grid
        
        for (let x = gridX - searchRadius; x <= gridX + searchRadius; x++) {
          for (let y = gridY - searchRadius; y <= gridY + searchRadius; y++) {
            const gridKey = `${x},${y}`;
            if (spatialGrid[gridKey]) {
              for (const g of spatialGrid[gridKey]) {
                // Only include points that are in the active set
                if (active.includes(g)) {
                  candidates.push({
                    feature: g,
                    distance: metersDistance(pt, g.geometry)
                  });
                }
              }
            }
          }
        }

        // If we didn't find enough points in the nearby grid cells, fall back to full search
        if (candidates.length < 4) {
          candidates = active.map(g => ({
            feature: g,
            distance: metersDistance(pt, g.geometry)
          }));
        }

        nearest = candidates
          .filter(o => o.distance <= 10000)
          .sort((a, b) => a.distance - b.distance)
          .slice(0, 4);

        for (const item of nearest) {
          const line = new Polyline({
            paths: [[pt.longitude, pt.latitude], [item.feature.geometry.longitude, item.feature.geometry.latitude]],
            spatialReference: { wkid: 4326 }
          });
          linesLayer.add(new Graphic({ geometry: line, symbol: lineSymbol }));
        }
        renderInfo();
      }

      function renderInfo() {
        let html = "<h4 style='margin:4px 0 6px'>Pontos de √°gua mais pr√≥ximos <small>(at√© 10 km)</small>:</h4>";
        if (!nearest.length) {
          html += "<p style='margin:0'>Nenhum ponto encontrado.</p>";
        } else {
          html += "<ul style='margin:0; padding-left: 16px; font-size: 12px;'>";
          for (const o of nearest) {
            const a = o.feature.attributes || {};
            const name = a.nome || "Sem nome";
            const type = a.tipologia ? (" (" + a.tipologia + ")") : "";
            html += "<li>" + name + type + " ‚Äî " + o.distance + " m</li>";
          }
          html += "</ul>";
        }
        infoContent.innerHTML = html;
      }

      // Build spatial grid when data is loaded
      setTimeout(() => {
        if (allPoints.length > 0) {
          buildSpatialGrid(allPoints);
        }
      }, 2000);

      // Fire data functions - MODIFICATO per gestire CORS
      function loadFireData() {
        fireDateDisplay.textContent = "Carregando dados de inc√™ndios...";
        
        // Mostra avviso CORS se siamo su GitHub Pages
        if (window.location.hostname.includes('github.io')) {
          document.getElementById('corsWarning').style.display = 'block';
        }
        
        // Define query based on selected region
        const region = fireRegion.value;
        let geometry = null;
        let where = "1=1";
        
        // Set spatial filter based on region
        if (region === "iberian_peninsula") {
          geometry = {
            xmin: -9.5, ymin: 36, xmax: 3.3, ymax: 43.8,
            spatialReference: { wkid: 4326 }
          };
        } else if (region === "europe") {
          geometry = {
            xmin: -25, ymin: 35, xmax: 40, ymax: 71,
            spatialReference: { wkid: 4326 }
          };
        }
        
        // Calculate date range (last X days)
        const daysToShow = parseInt(fireDays.value);
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - daysToShow);
        
        const startDateStr = formatDateForQuery(startDate);
        const endDateStr = formatDateForQuery(endDate);
        
        where = `acq_date >= '${startDateStr}' AND acq_date <= '${endDateStr}'`;
        
        // Create feature layer with query - MODIFICATO per gestire CORS
        const layer = new FeatureLayer({
          url: fireServiceUrl,
          definitionExpression: where,
          outFields: ["*"]
        });
        
        // Query features - MODIFICATO per gestire CORS
        const query = layer.createQuery();
        if (geometry) {
          query.geometry = geometry;
        }
        query.outFields = ["*"];
        query.returnGeometry = true;
        query.where = where;
        
        // Usa una richiesta diretta per evitare problemi CORS
        const queryUrl = `${fireServiceUrl}/query?f=json&where=${encodeURIComponent(where)}&outFields=*&returnGeometry=true`;
        
        // Prova prima con una richiesta standard
        fetch(queryUrl, {
          mode: 'cors',
          credentials: 'omit'
        })
        .then(response => {
          if (!response.ok) throw new Error('Network response was not ok');
          return response.json();
        })
        .then(data => {
          if (data.error) {
            throw new Error(data.error.message);
          }
          processFireData(data.features);
        })
        .catch(error => {
          console.error("Error loading fire data:", error);
          fireDateDisplay.textContent = "Erro ao carregar dados";
          showError("N√£o foi poss√≠vel carregar dados de inc√™ndios. Problema de CORS.");
          
          // Prova con un proxy CORS alternativo
          tryWithCorsProxy(queryUrl);
        });
      }
      
      function formatDateForQuery(date) {
        // Formatta la data nel formato YYYY-MM-DD per la query
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      }
      
      function tryWithCorsProxy(queryUrl) {
        // Usa un proxy CORS come ultima risorsa
        const proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(queryUrl);
        
        fetch(proxyUrl, {
          credentials: 'omit'
        })
        .then(response => {
          if (!response.ok) throw new Error('Proxy response was not ok');
          return response.json();
        })
        .then(data => {
          if (data.error) {
            throw new Error(data.error.message);
          }
          processFireData(data.features);
        })
        .catch(error => {
          console.error("Error loading fire data with proxy:", error);
          fireDateDisplay.textContent = "Falha ao carregar mesmo com proxy";
          showError("Falha completa ao carregar dados de inc√™ndios.");
        });
      }
      
      function processFireData(features) {
        if (!features || !Array.isArray(features)) {
          console.error("Invalid features data:", features);
          fireDateDisplay.textContent = "Dados de inc√™ndio inv√°lidos";
          return;
        }
        
        // Group fires by date
        const firesByDate = {};
        
        features.forEach((feature) => {
          const attributes = feature.attributes;
          const geometry = feature.geometry;
          
          if (!attributes || !geometry) return;
          
          const date = attributes.acq_date;
          if (!date) return;
          
          if (!firesByDate[date]) {
            firesByDate[date] = [];
          }
          
          // Create graphic for fire point - MODIFICATO per gestire geometria corretta
          let point;
          if (geometry.x && geometry.y) {
            point = new Point({
              x: geometry.x,
              y: geometry.y,
              spatialReference: geometry.spatialReference || { wkid: 4326 }
            });
          } else if (geometry.longitude && geometry.latitude) {
            point = new Point({
              longitude: geometry.longitude,
              latitude: geometry.latitude,
              spatialReference: geometry.spatialReference || { wkid: 4326 }
            });
          } else if (geometry.points && geometry.points.length > 0) {
            // Gestione per geometrie multipunto
            point = new Point({
              x: geometry.points[0][0],
              y: geometry.points[0][1],
              spatialReference: geometry.spatialReference || { wkid: 4326 }
            });
          } else {
            return; // Skip if no valid geometry
          }
          
          // Choose symbol based on intensity (frp)
          let symbol = lowFireSymbol;
          const frp = attributes.frp || 0;
          if (frp > 50) symbol = highFireSymbol;
          else if (frp > 10) symbol = mediumFireSymbol;
          
          firesByDate[date].push(new Graphic({
            geometry: point,
            attributes: attributes,
            symbol: symbol,
            popupTemplate: {
              title: "Inc√™ndio {acq_date}",
              content: function(event) {
                const g = event.graphic;
                const attrs = g.attributes || {};
                return `
                  <div>
                    <p><strong>Data:</strong> ${attrs.acq_date || 'N/A'}</p>
                    <p><strong>Hora:</strong> ${attrs.acq_time || 'N/A'}</p>
                    <p><strong>Intensidade (FRP):</strong> ${attrs.frp || 'N/A'} MW</p>
                    <p><strong>Confian√ßa:</strong> ${attrs.confidence || 'N/A'}%</p>
                    <p><strong>Sat√©lite:</strong> ${attrs.satellite || 'N/A'}</p>
                  </div>
                `;
              }
            }
          }));
        });
        
        // Convert to array and sort by date
        fireData = Object.entries(firesByDate)
          .map(([date, graphics]) => ({ date, graphics }))
          .sort((a, b) => new Date(a.date) - new Date(b.date));
        
        if (fireData.length > 0) {
          currentFireDateIndex = fireData.length - 1; // Start with most recent
          showFireDataForCurrentDate();
          setupFirePlayerControls();
        } else {
          fireDateDisplay.textContent = "Nenhum dado de inc√™ndio encontrado";
        }
      }
      
      function showFireDataForCurrentDate() {
        fireLayer.removeAll();
        
        if (fireData.length === 0) return;
        
        const currentDateData = fireData[currentFireDateIndex];
        
        // CORREZIONE: Formatta correttamente la data
        const formattedDate = formatFireDate(currentDateData.date);
        fireDateDisplay.textContent = `Inc√™ndios em ${formattedDate}`;
        
        // Add graphics to layer
        fireLayer.addMany(currentDateData.graphics);
        
        // Update progress bar
        const progress = ((currentFireDateIndex + 1) / fireData.length) * 100;
        fireProgressBar.style.width = `${progress}%`;
      }
      
      function formatFireDate(dateStr) {
        // CORREZIONE: Gestione robusta della formattazione della data
        if (!dateStr) return "Data desconhecida";
        
        try {
          // Prova diversi formati di data
          let date;
          
          if (dateStr.includes('/')) {
            // Formato DD/MM/YYYY o MM/DD/YYYY
            const parts = dateStr.split('/');
            if (parts.length === 3) {
              // Assumi formato YYYY/MM/DD o DD/MM/YYYY
              if (parts[0].length === 4) {
                // Formato YYYY/MM/DD
                date = new Date(parts[0], parts[1] - 1, parts[2]);
              } else {
                // Formato DD/MM/YYYY
                date = new Date(parts[2], parts[1] - 1, parts[0]);
              }
            }
          } else if (dateStr.includes('-')) {
            // Formato YYYY-MM-DD
            date = new Date(dateStr);
          } else {
            // Prova a parsare direttamente
            date = new Date(dateStr);
          }
          
          // Verifica se la data √® valida
          if (isNaN(date.getTime())) {
            return dateStr; // Ritorna la stringa originale se non pu√≤ essere parsata
          }
          
          return date.toLocaleDateString('pt-PT');
        } catch (e) {
          console.error("Error formatting date:", e, dateStr);
          return dateStr; // Ritorna la stringa originale in caso di errore
        }
      }
      
      function setupFirePlayerControls() {
        // Previous button
        firePrev.addEventListener("click", () => {
          stopFireAnimation();
          if (currentFireDateIndex > 0) {
            currentFireDateIndex--;
            showFireDataForCurrentDate();
          }
        });
        
        // Next button
        fireNext.addEventListener("click", () => {
          stopFireAnimation();
          if (currentFireDateIndex < fireData.length - 1) {
            currentFireDateIndex++;
            showFireDataForCurrentDate();
          }
        });
        
        // Play/Pause button
        firePlayPause.addEventListener("click", () => {
          if (fireAnimationInterval) {
            stopFireAnimation();
            firePlayPause.innerHTML = "‚ñ∂";
            firePlayPause.title = "Reproduzir";
          } else {
            startFireAnimation();
            firePlayPause.innerHTML = "‚è∏";
            firePlayPause.title = "Pausar";
          }
        });
        
        // Region change
        fireRegion.addEventListener("change", () => {
          stopFireAnimation();
          fireData = [];
          loadFireData();
        });
        
        // Days change
        fireDays.addEventListener("change", () => {
          stopFireAnimation();
          fireData = [];
          loadFireData();
        });
      }
      
      function startFireAnimation() {
        stopFireAnimation();
        
        fireAnimationInterval = setInterval(() => {
          if (currentFireDateIndex < fireData.length - 1) {
            currentFireDateIndex++;
            showFireDataForCurrentDate();
          } else {
            // Reached the end, stop animation
            stopFireAnimation();
            firePlayPause.innerHTML = "‚ñ∂";
            firePlayPause.title = "Reproduzir";
          }
        }, 1500); // 1.5 seconds per frame
      }
      
      function stopFireAnimation() {
        if (fireAnimationInterval) {
          clearInterval(fireAnimationInterval);
          fireAnimationInterval = null;
        }
      }

      // Robust error reporting (in case both loaders fail)
      window.addEventListener("unhandledrejection", (e) => {
        console.warn("Unhandled rejection:", e.reason);
        showError("Ocorreu um erro inesperado. Recarregue a p√°gina.");
      });
    });
  </script>
</body>
</html>